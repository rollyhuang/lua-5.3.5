#define repl_c
#include <uvwrap.h>

#ifndef _WIN32 /* { */

#include <readline/readline.h>
#include <readline/history.h>

#define RL_INIT()
#define READLINE(p) readline(p)
#define SAVELINE(line) add_history(line)
#define FREELINE(b) free((void*)b)
#define RESTTERM() (void)rl_reset_terminal(NULL)

#else /* }{ */

#define LUA_MAXINPUT 512
#define RL_INIT() char __buffer__[LUA_MAXINPUT]

#define READLINE(p) \
  (fputs(p, stdout), \
   fflush(stdout), /* show prompt */ \
   fgets(__buffer__, LUA_MAXINPUT, stdin)) /* get line */
#define SAVELINE(line) \
  { \
    (void)line; \
  }
#define FREELINE(b) \
  { \
    (void)b; \
  }
#define RESTTERM()

#endif /* } */

#if !defined(lua_assert)
#define lua_assert(x) ((void)0)
#endif

/*
** {======================================================
** Functions from lua.c
** =======================================================
*/

#define LUA_PROGNAME "lua"
#define LUA_PROMPT "> "
#define LUA_PROMPT2 ">> "

static const char* progname = LUA_PROGNAME;

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char* pname, const char* msg) {
  if (pname)
    lua_printf("%s: ", pname);
  lua_printf("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
// [-(0|1), +0, -], need 0 slot
static int report(lua_State* L, int status) {
  if (status != LUA_OK) {
    const char* msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State* L) {
  const char* msg = lua_tostring(L, 1);
  if (msg == NULL) { /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") && /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING) /* that produces a string? */
      return 1; /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)", luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1); /* append a standard traceback */
  return 1; /* return the traceback */
}

/*
** Returns the string to be used as a prompt by the interpreter.
*/
// [-0, +1, -]
static const char* get_prompt(lua_State* L, int firstline) {
  const char* p;
  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
  p = lua_tostring(L, -1);
  if (p == NULL) {
    lua_pop(L, 1);
    p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
    lua_pushstring(L, p);
  }
  return p;
}

/* mark in error messages for incomplete statements */
#define EOFMARK "<eof>"
#define marklen (sizeof(EOFMARK) / sizeof(char) - 1)

/*
** Check whether 'status' signals a syntax error and the error
** message at the top of the stack ends with the above mark for
** incomplete statements.
*/
// [-(0|1), +0, -], need 0 slot
static int incomplete(lua_State* L, int status) {
  if (status == LUA_ERRSYNTAX) {
    size_t lmsg;
    const char* msg = lua_tolstring(L, -1, &lmsg);
    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
      lua_pop(L, 1);
      return 1;
    }
  }
  return 0; /* else... */
}

/*
** Prints (calling the Lua 'print' function) any values on the stack
*/
// [-n, +0, -]
static void l_print(lua_State* L) {
  int n = lua_gettop(L);
  if (n > 0) { /* any result to be printed? */
    luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
    lua_getglobal(L, "print");
    lua_insert(L, 1);
    if (lua_pcall(L, n, 0, 0) != LUA_OK) {
      l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)", lua_tostring(L, -1)));
      lua_settop(L, 0);
    }
  }
}

// [-0, +0, -]
static void call_registry_funcs(lua_State* L, const char* name, const char* msg) {
  if (lua_getfield(L, LUA_REGISTRYINDEX, name) == LUA_TTABLE) {
    int idx = lua_gettop(L);
    lua_pushcfunction(L, msghandler);
    lua_pushnil(L);
    while (lua_next(L, idx)) {
      if (lua_pcall(L, 0, 0, idx + 1) != LUA_OK) {
        lua_printf(msg, lua_tostring(L, -1));
        lua_pop(L, 1);
      }
    }
    lua_pop(L, 1);
  }
  lua_pop(L, 1);
}

/* }====================================================== */

static int docall(lua_State* L, int narg, int nres) {
  int base = lua_gettop(L) - narg; /* function index */
  lua_pushcfunction(L, msghandler); /* push message handler */
  lua_insert(L, base); /* put it under function and args */
  int status = lua_pcall(L, narg, nres, base);
  lua_remove(L, base); /* remove message handler from the stack */
  return status;
}

#define REPL_OBJECT "_REPL_OBJECT_"
#define REPL_PROMPT "_REPL_PROMPT_"
#define REPL_HISTORY "_REPL_HISTORY_"
#define REPL_ONEVAL "_REPL_ONEVAL_"

#define GET_REGISTRY_FIELD(field_) lua_getfield(L, LUA_REGISTRYINDEX, field_)
#define SET_REGISTRY_FIELD(field_) lua_setfield(L, LUA_REGISTRYINDEX, field_)
#define CLEAR_REGISTRY_FIELD(field_) \
  lua_pushnil(L); \
  lua_setfield(L, LUA_REGISTRYINDEX, field_)

// [-0, +0, -]
static const char* get_prompt_hold(lua_State* L, int firstline) {
  const char* prmt = get_prompt(L, firstline);
  SET_REGISTRY_FIELD(REPL_PROMPT);
  return prmt;
}

static void save_history(const char* line) {
  if (line != NULL && line[0] != '\0') { /* non empty? */
    SAVELINE(line); /* keep history */
  }
}

/*
** {======================================================
** REPL Feature
** =======================================================
*/

typedef bool (*lua_Eval)(void* ud, const char* code, bool bEOF, const char** pPrompt, const char** pHistory);
typedef void (*lua_Shutdown)(void* ud);
typedef struct {
  /* Context */
  bool bRunning;
  bool bInit;
  bool bOneShot;
  lua_Eval eval;
  lua_Shutdown shutdown;
  void* ud;
  uv_thread_t tid[1];
  /* Data Transmission */
  uv_async_t async[1];
  uv_sem_t sem[1];
  /* Read */
  const char* code; // Set by readline thread, clear by itself, used by eval callback
  bool bEOF;
  /* Print */
  const char* prompt; // Set by init or eval
  const char* history; // Set by eval
} lua_REPL;
void repl_init(lua_REPL* repl, uv_loop_t* loop, const char* firstPrompt, bool bOneShot, lua_Eval eval, lua_Shutdown shutdown, void* ud);
void repl_shutdown(lua_REPL* repl);
bool repl_next(lua_REPL* repl, bool bRunning, const char* prompt, const char* history);
bool repl_isOneShot(lua_REPL* repl);

bool repl_defaultEval(void* ud, const char* code, bool bEOF, const char** pPrompt, const char** pHistory);

#define MSG_START "Multi thread REPL starting...\n"
#define MSG_STOP "Multi thread REPL end.\n"
static void thread_readLine(void* arg) {
  lua_REPL* repl = (lua_REPL*)arg;
  RL_INIT();
  lua_flushstring(MSG_START, sizeof(MSG_START));
  while (repl->bRunning) { // for Ctrl-D in Unix or Ctrl-Z in Windows
    const char* buffer = READLINE(repl->prompt);

    // Read Send code and Wait
    repl->code = buffer;
    repl->bEOF = buffer == NULL;
    uv_async_send(repl->async);
    uv_sem_wait(repl->sem);

    repl->code = NULL;
    FREELINE(buffer);
    save_history(repl->history);
  }
  lua_flushstring(MSG_STOP, sizeof(MSG_STOP));
  RESTTERM();
}
static void repl_nextInternal(lua_REPL* repl, bool bRunning, const char* prompt, const char* history) {
  assert(repl->bRunning);
  repl->bRunning = bRunning;
  repl->prompt = prompt;
  repl->history = history;
  if (repl->bRunning) {
    uv_sem_post(repl->sem); // Fire next readline
  } else {
    repl_shutdown(repl);
  }
}
static void async_doREPL(uv_async_t* handle) {
  lua_REPL* repl = uv_handle_get_data((const uv_handle_t*)handle);
  const char* prompt;
  const char* history;
  bool bRunning = repl->eval(repl->ud, repl->code, repl->bEOF, &prompt, &history);
  if (repl->bOneShot) {
  } else {
    repl_nextInternal(repl, bRunning, prompt, history);
  }
}
void repl_init(lua_REPL* repl, uv_loop_t* loop, const char* firstPrompt, bool bOneShot, lua_Eval eval, lua_Shutdown shutdown, void* ud) {
  memset(repl, 0, sizeof(lua_REPL));
  /* Data Transmission */
  uv_async_init(loop, repl->async, async_doREPL);
  uv_handle_set_data((uv_handle_t*)repl->async, (void*)repl);
  uv_sem_init(repl->sem, 0);
  /* Read */
  repl->code = NULL;
  repl->bEOF = false;
  /* Print */
  repl->prompt = firstPrompt;
  repl->history = NULL;
  /* Context */
  repl->bRunning = true;
  repl->bInit = true;
  repl->bOneShot = bOneShot;
  repl->eval = eval;
  repl->shutdown = shutdown;
  repl->ud = ud;
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  uv_thread_create(repl->tid, thread_readLine, (void*)repl);
}
static void async_onClose(uv_handle_t* handle) {
  lua_REPL* repl = uv_handle_get_data(handle);
  repl->shutdown(repl->ud);
  memset(repl, 0, sizeof(lua_REPL));
}
void repl_shutdown(lua_REPL* repl) {
  if (repl->bInit) {
    repl->bInit = false;
    uv_sem_post(repl->sem); // Maybe thread block in sem, so post it, maybe block in readline?
    uv_thread_join(repl->tid);
    uv_sem_destroy(repl->sem);
    uv_close((uv_handle_t*)repl->async, async_onClose);
  }
}
bool repl_next(lua_REPL* repl, bool bRunning, const char* prompt, const char* history) {
  if (repl->bRunning && repl->bOneShot) {
    repl_nextInternal(repl, bRunning, prompt, history);
  }
  return repl->bRunning;
}
bool repl_isOneShot(lua_REPL* repl) {
  return repl->bOneShot;
}

/* }====================================================== */

/*
** {======================================================
** REPL Default Eval
** =======================================================
*/

// [-(0|1), +0, -], need 0 slot
static int report_with_print(lua_State* L, int status) {
  if (status != LUA_OK) {
    lua_getglobal(L, "print");
    if (progname) {
      const char* msg = lua_tostring(L, -2);
      lua_pushfstring(L, "%s: %s", progname, msg);
    } else {
      // lua_pushfstring(L, "%s", msg);
      lua_pushvalue(L, -2);
    }
    if (lua_pcall(L, 1, 0, 0) != LUA_OK) {
      lua_pop(L, 1); // pop the error message
    }
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

static bool firstline = true;
// [-0, +2, -]
int compile_source_code(lua_State* L, const char* code, const char** phistory) {
  char* b = (char*)code;
  size_t l = strlen(b);
  if (l > 0 && b[l - 1] == '\n') { /* line ends with newline? */
    b[--l] = '\0'; /* remove it */
  }
  bool hasClosure = false;
  if (firstline) {
    if (b[0] == '=') { /* for compatibility with 5.2, ... */
      lua_pushfstring(L, "return %s", b + 1); /* change '=' to 'return' */
    } else {
      lua_pushlstring(L, b, l);
      const char* retline = lua_pushfstring(L, "return %s;", b);
      if (luaL_loadbuffer(L, retline, strlen(retline), "=stdin") == LUA_OK) {
        lua_remove(L, -2); /* remove modified line */
        lua_insert(L, -2); // move the history string to top
        hasClosure = true;
      } else {
        lua_pop(L, 2); /* pop result from 'luaL_loadbuffer' and modified line */
      }
    }
  } else {
    GET_REGISTRY_FIELD(REPL_HISTORY);
    lua_pushliteral(L, "\n"); /* add newline... */
    lua_pushlstring(L, b, l);
    lua_concat(L, 3); /* join them */
  }
  size_t len = 0;
  const char* line = lua_tolstring(L, -1, &len);
  if (phistory) {
    *phistory = line;
  }
  SET_REGISTRY_FIELD(REPL_HISTORY);
  if (hasClosure) {
    return LUA_OK;
  }
  return luaL_loadbuffer(L, line, len, "=stdin"); /* try it */
}

bool repl_defaultEval(void* ud, const char* code, bool bEOF, const char** pPrompt, const char** pHistory) {
  (void)ud;
  lua_State* L = GET_MAIN_LUA_STATE();
  bool running = true;
  *pHistory = NULL;
  if (bEOF) { // Ctrl-D or Ctrl-Z+Enter
    if (firstline) {
      running = false;
    } else {
      firstline = true; // end multi line
      GET_REGISTRY_FIELD(REPL_HISTORY);
      *pHistory = lua_tostring(L, -1);
      lua_pop(L, 1);
    }
    lua_getglobal(L, "print");
    if (running) {
      lua_getglobal(L, "_PROMPT2");
      lua_pushfstring(L, "%s", lua_tostring(L, -1));
      lua_remove(L, -2);
    }
    if (lua_pcall(L, running ? 1 : 0, 0, 0) != LUA_OK) {
      lua_printf_err("%s\n", lua_tostring(L, -1));
      lua_pop(L, 1); // pop the error message
    }
  } else {
    const char* history;
    int status = compile_source_code(L, code, &history);
    if (incomplete(L, status)) {
      // incomplete will pop the error message if return true
      firstline = false;
    } else {
      firstline = true;
      *pHistory = history;
      if (status == LUA_OK) {
        if (lua_gettop(L) != 1) {
          lua_replace(L, 1);
          lua_settop(L, 1); // Only left the closure
        }
        status = docall(L, 0, LUA_MULTRET);
        if (status == LUA_OK) {
          l_print(L); // print direct
        }
      }
      report_with_print(L, status); // will pop the error message
      call_registry_funcs(L, LUA_ATREPL, "Call atrepl failed: %s\n");
    }
  }
  *pPrompt = get_prompt_hold(L, firstline);
  return running;
}

/* }====================================================== */

/*
** {======================================================
** REPL Wrap
** =======================================================
*/

#define REPL_TYPE "lua_REPL*"
static bool uvwrap_onEval(void* ud, const char* code, bool bEOF, const char** pPrompt, const char** pHistory) {
  lua_State* L = GET_MAIN_LUA_STATE();
  int top = lua_gettop(L);
  bool bOneShot = repl_isOneShot((lua_REPL*)ud);
  GET_REGISTRY_FIELD(REPL_ONEVAL);
  lua_pushstring(L, code);
  lua_pushboolean(L, bEOF);
  int status = docall(L, 2, bOneShot ? 0 : 3);
  if (status == LUA_OK) {
    if (bOneShot) {
      return true;
    }
    bool bRunning = lua_toboolean(L, top + 1);
    *pPrompt = lua_tostring(L, top + 2);
    *pHistory = lua_tostring(L, top + 3);
    if (*pHistory != NULL) { // for using REPL_HISTORY to cache multiline in default implementationÏ
      SET_REGISTRY_FIELD(REPL_HISTORY);
    } else {
      lua_pop(L, 1);
    }
    SET_REGISTRY_FIELD(REPL_PROMPT);
    lua_pop(L, 1);
    return bRunning;
  } else {
    report(L, status);
    *pPrompt = NULL;
    *pHistory = NULL;
    return false;
  }
}
static void uvwrap_onClose(void* ud) {
  (void)ud;
  lua_State* L = GET_MAIN_LUA_STATE();
  CLEAR_REGISTRY_FIELD(REPL_OBJECT);
  CLEAR_REGISTRY_FIELD(REPL_PROMPT);
  CLEAR_REGISTRY_FIELD(REPL_HISTORY);
  CLEAR_REGISTRY_FIELD(REPL_ONEVAL);
}
int uvwrap_replStart(lua_State* L) {
  GET_REGISTRY_FIELD(REPL_OBJECT);
  if (luaL_testudata_recursive(L, -1, REPL_TYPE)) {
    return luaL_error(L, "REPL is already running");
  }
  lua_pop(L, 1);
  lua_REPL* repl = (lua_REPL*)lua_newuserdata(L, sizeof(lua_REPL));
  uv_loop_t* loop = luaL_checkuvloop(L, 1);
  int bOneShot = luaL_checkboolean(L, 2);
  lua_Eval eval;
  const char* prompt;
#define EVAL_IDX 3
  if (lua_isfunction(L, EVAL_IDX)) {
    lua_pushvalue(L, EVAL_IDX);
    SET_REGISTRY_FIELD(REPL_ONEVAL);
    eval = uvwrap_onEval;
    prompt = luaL_checkstring(L, EVAL_IDX + 1);
    lua_pushvalue(L, EVAL_IDX + 1);
    SET_REGISTRY_FIELD(REPL_PROMPT);
  } else if (bOneShot) {
    return luaL_error(L, "One shot REPL must has a callback function");
  } else {
    eval = repl_defaultEval;
    prompt = get_prompt_hold(L, true);
  }
#undef EVAL_IDX
  repl_init(repl, loop, prompt, bOneShot, eval, uvwrap_onClose, (void*)repl);
  luaL_setmetatable(L, REPL_TYPE);
  SET_REGISTRY_FIELD(REPL_OBJECT);
  return 0;
}
int uvwrap_replShutdown(lua_State* L) {
  GET_REGISTRY_FIELD(REPL_OBJECT);
  lua_REPL* repl = (lua_REPL*)luaL_checkudata_recursive(L, -1, REPL_TYPE);
  repl_shutdown(repl);
  return 0;
}
int uvwrap_replNext(lua_State* L) {
  bool bRunning = luaL_checkboolean(L, 1);
  const char* pPrompt = luaL_checkstring(L, 2);
  const char* pHistory = luaL_checkstring(L, 3);
  GET_REGISTRY_FIELD(REPL_OBJECT);
  lua_REPL* repl = (lua_REPL*)luaL_checkudata_recursive(L, -1, REPL_TYPE);
  bool ret = repl_next(repl, bRunning, pPrompt, pHistory);
  lua_pushboolean(L, ret);
  return 1;
}
int uvwrap_replIsOneShot(lua_State* L) {
  GET_REGISTRY_FIELD(REPL_OBJECT);
  lua_REPL* repl = (lua_REPL*)luaL_checkudata_recursive(L, -1, REPL_TYPE);
  bool ret = repl_isOneShot(repl);
  lua_pushboolean(L, ret);
  return 1;
}
int uvwrap_replDefaultEval(lua_State* L) {
  const char* code = luaL_optstring(L, 1, NULL);
  bool bEOF = luaL_checkboolean(L, 2);
  const char* pPrompt;
  const char* pHistory;
  bool running = repl_defaultEval(NULL, code, bEOF, &pPrompt, &pHistory);
  lua_pushboolean(L, running);
  lua_pushstring(L, pPrompt);
  lua_pushstring(L, pHistory);
  return 3;
}

int uvwrap_replRead(lua_State* L) {
  const char* prompt = luaL_checkstring(L, 1);

  RL_INIT();
  char* buffer = READLINE(prompt);
  lua_pushstring(L, buffer);
  FREELINE(buffer);
  return 1;
}
int uvwrap_replHistory(lua_State* L) {
  const char* history = lua_tostring(L, 1);
  save_history(history);
  return 0;
}

static int uvwrap_repl__gc(lua_State* L) {
  lua_REPL* repl = (lua_REPL*)luaL_checkudata_recursive(L, 1, REPL_TYPE);
  repl_shutdown(repl);
  return 0;
}
static const luaL_Reg uvwrap_replMetaFuncs[] = {
    {"__gc", uvwrap_repl__gc},
    {NULL, NULL},
};
void uvwrap_replInitMetatable(lua_State* L) {
  luaL_newmetatable(L, REPL_TYPE);
  luaL_setfuncs(L, uvwrap_replMetaFuncs, 0);

  lua_pushvalue(L, -1);
  lua_setfield(L, -2, "__index");

  lua_pop(L, 1);
}

/* }====================================================== */
